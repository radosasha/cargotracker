package com.shiplocate.data.mapper

import com.shiplocate.core.database.entity.LoadEntity
import com.shiplocate.core.database.entity.StopEntity
import com.shiplocate.data.network.dto.load.LegDto
import com.shiplocate.data.network.dto.load.LoadDto
import com.shiplocate.data.network.dto.load.LocalizedValueDto
import com.shiplocate.data.network.dto.load.LocalizedValuesDto
import com.shiplocate.data.network.dto.load.NavigationInstructionDto
import com.shiplocate.data.network.dto.load.PolylineDto
import com.shiplocate.data.network.dto.load.RouteDto
import com.shiplocate.data.network.dto.load.RouteLatLngDto
import com.shiplocate.data.network.dto.load.StepDto
import com.shiplocate.data.network.dto.load.StopDto
import com.shiplocate.data.network.dto.load.WaypointLocationDto
import com.shiplocate.domain.model.load.Leg
import com.shiplocate.domain.model.load.Load
import com.shiplocate.domain.model.load.LoadStatus
import com.shiplocate.domain.model.load.LocalizedValue
import com.shiplocate.domain.model.load.LocalizedValues
import com.shiplocate.domain.model.load.NavigationInstruction
import com.shiplocate.domain.model.load.Polyline
import com.shiplocate.domain.model.load.Route
import com.shiplocate.domain.model.load.RouteLatLng
import com.shiplocate.domain.model.load.Step
import com.shiplocate.domain.model.load.StepCoordinate
import com.shiplocate.domain.model.load.Stop
import com.shiplocate.domain.model.load.WaypointLocation

fun LoadDto.toDomain(): Load {
    return Load(
        id = id, // Internal ID for application operations
        serverId = id, // serverId используется для API вызовов (must match server's ID)
        loadName = loadName, // Name for UI display
        description = description,
        lastUpdated = lastUpdated,
        createdAt = createdAt,
        loadStatus = loadStatus.toLoadStatus(),
        stops = stops.map { it.toDomain() },
    )
}

fun Int.toLoadStatus(): LoadStatus {
    return when (this) {
        1 -> LoadStatus.LOAD_STATUS_NOT_CONNECTED
        4 -> LoadStatus.LOAD_STATUS_CONNECTED
        5 -> LoadStatus.LOAD_STATUS_DISCONNECTED
        3 -> LoadStatus.LOAD_STATUS_REJECTED
        else -> LoadStatus.LOAD_STATUS_UNKNOWN
    }
}

fun LoadDto.toEntity(): LoadEntity {
    return LoadEntity(
        loadName = loadName, // Name for UI display
        id = id, // Internal ID for application operations
        serverId = id, // serverId используется для API вызовов (must match server's ID)
        description = description,
        lastUpdated = lastUpdated,
        createdAt = createdAt,
        loadStatus = loadStatus,
    )
}

fun LoadDto.toStopEntities(loadId: Long): List<StopEntity> {
    return stops.map { stopDto ->
        StopEntity(
            loadId = loadId,
            serverId = stopDto.id,
            type = stopDto.type,
            locationName = stopDto.locationName,
            locationAddress = stopDto.locationAddress,
            date = stopDto.date,
            geofenceRadius = stopDto.geofenceRadius,
            stopIndex = stopDto.index,
            latitude = stopDto.latitude,
            longitude = stopDto.longitude,
            enter = stopDto.enter,
            note = stopDto.note,
            completion = stopDto.completion
        )
    }
}

fun StopDto.toDomain(): Stop {
    return Stop(
        id = id,
        type = type,
        locationName = locationName,
        locationAddress = locationAddress,
        date = date,
        geofenceRadius = geofenceRadius,
        index = index,
        latitude = latitude,
        longitude = longitude,
        enter = enter,
        note = note,
        completion = completion
    )
}

fun StopDto.toStopEntity(loadId: Long): StopEntity {
    return StopEntity(
        loadId = loadId,
        serverId = id,
        type = type,
        locationName = locationName,
        locationAddress = locationAddress,
        date = date,
        geofenceRadius = geofenceRadius,
        stopIndex = index,
        latitude = latitude,
        longitude = longitude,
        enter = enter,
        note = note,
        completion = completion
    )
}

fun StopEntity.toDomain(): Stop {
    return Stop(
        id = serverId,
        type = type,
        locationName = locationName,
        locationAddress = locationAddress,
        date = date,
        geofenceRadius = geofenceRadius,
        index = stopIndex,
        latitude = latitude,
        longitude = longitude,
        enter = enter,
        note = note,
        completion = completion
    )
}

fun Stop.toEntity(loadId: Long): StopEntity {
    return StopEntity(
        id = 0, // Auto-generated by Room
        loadId = loadId,
        serverId = id,
        type = type,
        locationName = locationName,
        locationAddress = locationAddress,
        date = date,
        geofenceRadius = geofenceRadius,
        stopIndex = index,
        latitude = latitude,
        longitude = longitude,
        enter = enter,
        note = note,
        completion = completion
    )
}

fun LoadEntity.toDomain(): Load {
    return Load(
        id = id,
        serverId = serverId,
        loadName = loadName,
        description = description,
        lastUpdated = lastUpdated,
        createdAt = createdAt,
        loadStatus = loadStatus.toLoadStatus(),
        stops = emptyList(), // Stops загружаются отдельно через StopsLocalDataSource
    )
}

fun LoadStatus.toInt(): Int {
    return when (this) {
        LoadStatus.LOAD_STATUS_NOT_CONNECTED -> 1
        LoadStatus.LOAD_STATUS_CONNECTED -> 4
        LoadStatus.LOAD_STATUS_DISCONNECTED -> 5
        LoadStatus.LOAD_STATUS_REJECTED -> 3
        LoadStatus.LOAD_STATUS_UNKNOWN -> 0
    }
}

fun Load.toEntity(): LoadEntity {
    return LoadEntity(
        id = id,
        serverId = serverId,
        loadName = loadName,
        description = description,
        lastUpdated = lastUpdated,
        createdAt = createdAt,
        loadStatus = loadStatus.toInt(),
    )
}

/**
 * Parse duration string like "24115s" to Int (seconds)
 */
private fun parseDuration(duration: String?): Int? {
    if (duration == null) return null
    return duration.removeSuffix("s").toIntOrNull()
}

/**
 * Decode Google encoded polyline to array of coordinates
 */
private fun decodePolyline(encoded: String?): List<StepCoordinate>? {
    if (encoded == null || encoded.isEmpty()) return null
    
    val coordinates = mutableListOf<StepCoordinate>()
    var index = 0
    var lat = 0
    var lng = 0
    
    while (index < encoded.length) {
        var shift = 0
        var result = 0
        var byte: Int
        do {
            byte = encoded[index++].code - 63
            result = result or ((byte and 0x1F) shl shift)
            shift += 5
        } while (byte >= 0x20)
        val deltaLat = if ((result and 1) != 0) ((result shr 1).inv()) else (result shr 1)
        lat += deltaLat
        
        shift = 0
        result = 0
        do {
            byte = encoded[index++].code - 63
            result = result or ((byte and 0x1F) shl shift)
            shift += 5
        } while (byte >= 0x20)
        val deltaLng = if ((result and 1) != 0) ((result shr 1).inv()) else (result shr 1)
        lng += deltaLng
        
        coordinates.add(StepCoordinate(
            latitude = lat / 1e5,
            longitude = lng / 1e5
        ))
    }
    
    return coordinates
}

fun RouteDto.toDomain(): Route {
    return Route(
        distanceMeters = distanceMeters,
        duration = parseDuration(duration),
        legs = legs?.map { it.toDomain() },
    )
}

fun LegDto.toDomain(): Leg {
    return Leg(
        distanceMeters = distanceMeters,
        duration = parseDuration(duration),
        polyline = polyline?.toDomain(),
        steps = steps?.map { it.toDomain() },
    )
}

fun StepDto.toDomain(): Step {
    return Step(
        distanceMeters = distanceMeters,
        staticDuration = parseDuration(staticDuration),
        polyline = decodePolyline(polyline?.encodedPolyline),
        startLocation = startLocation?.toDomain(),
        endLocation = endLocation?.toDomain(),
        navigationInstruction = navigationInstruction?.toDomain(),
        localizedValues = localizedValues?.toDomain(),
        travelMode = travelMode,
    )
}

fun WaypointLocationDto.toDomain(): WaypointLocation {
    return WaypointLocation(
        latLng = latLng?.toDomain(),
    )
}

fun RouteLatLngDto.toDomain(): RouteLatLng {
    return RouteLatLng(
        latitude = latitude,
        longitude = longitude,
    )
}

fun PolylineDto.toDomain(): Polyline {
    return Polyline(
        encodedPolyline = encodedPolyline,
    )
}

fun NavigationInstructionDto.toDomain(): NavigationInstruction {
    return NavigationInstruction(
        maneuver = maneuver,
        instructions = instructions,
    )
}

fun LocalizedValuesDto.toDomain(): LocalizedValues {
    return LocalizedValues(
        distance = distance?.toDomain(),
        staticDuration = staticDuration?.toDomain(),
    )
}

fun LocalizedValueDto.toDomain(): LocalizedValue {
    return LocalizedValue(
        text = text,
    )
}

/**
 * Convert duration Int (seconds) to String format like "24115s"
 */
private fun formatDuration(duration: Int?): String? {
    return duration?.let { "${it}s" }
}

/**
 * Encode array of coordinates to Google encoded polyline
 */
private fun encodePolyline(coordinates: List<StepCoordinate>?): PolylineDto? {
    if (coordinates == null || coordinates.isEmpty()) return null
    
    val encoded = StringBuilder()
    var prevLat = 0
    var prevLng = 0
    
    for (coord in coordinates) {
        val lat = (coord.latitude * 1e5).toInt()
        val lng = (coord.longitude * 1e5).toInt()
        
        val deltaLat = lat - prevLat
        val deltaLng = lng - prevLng
        
        encodeValue(deltaLat, encoded)
        encodeValue(deltaLng, encoded)
        
        prevLat = lat
        prevLng = lng
    }
    
    return PolylineDto(encodedPolyline = encoded.toString())
}

/**
 * Encode a single value for polyline encoding
 */
private fun encodeValue(value: Int, encoded: StringBuilder) {
    var v = if (value < 0) ((value shl 1).inv()) else (value shl 1)
    while (v >= 0x20) {
        encoded.append((0x20 or (v and 0x1F) + 63).toChar())
        v = v shr 5
    }
    encoded.append((v + 63).toChar())
}

fun Route.toDto(): RouteDto {
    return RouteDto(
        distanceMeters = distanceMeters,
        duration = formatDuration(duration),
        legs = legs?.map { it.toDto() },
    )
}

fun Leg.toDto(): LegDto {
    return LegDto(
        distanceMeters = distanceMeters,
        duration = formatDuration(duration),
        polyline = polyline?.toDto(),
        steps = steps?.map { it.toDto() },
    )
}

fun Step.toDto(): StepDto {
    return StepDto(
        distanceMeters = distanceMeters,
        staticDuration = formatDuration(staticDuration),
        polyline = encodePolyline(polyline),
        startLocation = startLocation?.toDto(),
        endLocation = endLocation?.toDto(),
        navigationInstruction = navigationInstruction?.toDto(),
        localizedValues = localizedValues?.toDto(),
        travelMode = travelMode,
    )
}

fun WaypointLocation.toDto(): WaypointLocationDto {
    return WaypointLocationDto(
        latLng = latLng?.toDto(),
    )
}

fun RouteLatLng.toDto(): RouteLatLngDto {
    return RouteLatLngDto(
        latitude = latitude,
        longitude = longitude,
    )
}

fun Polyline.toDto(): PolylineDto {
    return PolylineDto(
        encodedPolyline = encodedPolyline,
    )
}

fun NavigationInstruction.toDto(): NavigationInstructionDto {
    return NavigationInstructionDto(
        maneuver = maneuver,
        instructions = instructions,
    )
}

fun LocalizedValues.toDto(): LocalizedValuesDto {
    return LocalizedValuesDto(
        distance = distance?.toDto(),
        staticDuration = staticDuration?.toDto(),
    )
}

fun LocalizedValue.toDto(): LocalizedValueDto {
    return LocalizedValueDto(
        text = text,
    )
}
